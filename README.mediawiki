= GoSerial =

A simple, cross-platform go library to read and write streams of bytes from a serial port.  Tested on OSX and windows, and should work on Linux.

<code>
import "github.com/tarm/goserial"
</code>

Goserial is a simple go package to allow you to read and write from the serial port as a stream of bytes.

It aims to have the same API on all platforms, including windows. As an added bonus, the windows package does not use cgo, so you can cross compile for windows from another platform. Unfortunately goinstall does not currently let you cross compile so you will have to do it manually:

<code>
GOOS=windows make clean install
</code>

Currently there is very little in the way of configurability. You can set the baud rate. Then you can Read(), Write(), or Close() the connection. Read() will block until at least one byte is returned. Write is the same. There is currently no exposed way to set the timeouts, though patches are welcome.

Currently all ports are opened with 8 data bits, 1 stop bit, no parity, no hardware flow control, and no software flow control. This works fine for many real devices and many faux serial devices including usb-to-serial converters and bluetooth serial ports.

You may Read() and Write() simulantiously on the same connection (from different goroutines).

Example usage:

<code>
package main

import (
      "github.com/tarm/goserial"
      "log"
)

func main() {
      c := &serial.Config{Name: "COM5", Baud: 115200}
      s, err := serial.OpenPort(c)
      if err != nil {
              log.Fatal(err)
      }

      n, err := s.Write([]byte("test"))
      if err != nil {
              log.Fatal(err)
      }

      buf := make([]byte, 128)
      n, err = s.Read(buf)
      if err != nil {
              log.Fatal(err)
      }
      log.Print("%q", buf[:n])
}
</code>

= func OpenPort =

<code>
func OpenPort(c *Config) (io.ReadWriteCloser, os.Error)
</code>

OpenPort opens a serial port with the specified configuration

== type Config ==

Config contains the information needed to open a serial port.

Currently few options are implemented, but more may be added in the future (patches welcome), so it is recommended that you create a new config addressing the fields by name rather than by order.

For example:

<code>
c0 := &serial.Config{Name: "COM45", Baud: 115200}</code>

or

<code>
c1 := new(serial.Config)
c1.Name = "/dev/tty.usbserial"
c1.Baud = 115200</code>

<code>
type Config struct {
    Name string
    Baud int
}</code>
